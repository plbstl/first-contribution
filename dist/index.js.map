{"version":3,"file":"index.js","names":[],"sources":["../src/utils/action-inputs.ts","../src/utils/add-labels.ts","../src/utils/add-reactions.ts","../src/utils/create-comment.ts","../src/utils/fc-event.ts","../src/utils/is-first-time-contributor.ts","../src/utils/is-supported-event.ts","../src/utils/was-the-first-contribution.ts","../src/main.ts","../src/index.ts"],"sourcesContent":["import * as core from '@actions/core'\nimport type { FCEvent } from './fc-event.ts'\n\n/**\n * Gets all inputs to first-contribution GitHub Action and categorize them.\n * @param event A `first-contribution` event.\n * @returns Labels and a message that can be added to the issue or pull request.\n */\nexport function get_action_inputs(event: FCEvent): ActionInputs {\n  return {\n    labels: get_labels_input(event.name),\n    msg: get_msg_input(event),\n    reactions: get_reactions_input(event.name)\n  }\n}\n\n/** Categorized inputs of the first-contribution GitHub Action. */\ninterface ActionInputs {\n  /** Relevant `-labels` input. */\n  labels: string[]\n  /** Relevant `-msg` input. */\n  msg: string\n  /**\n   * List of emoji names to react with.\n   *\n   * Would be one of: `+1`, `-1`, `laugh`, `confused`, `heart`, `hooray`, `rocket`, `eyes`.\n   */\n  reactions: string[]\n}\n\n/**\n * Retrieves the relevant `-labels` input or a fallback.\n * @param event_name A `first-contribution` event name.\n * @returns An array of labels to add to the issue or pull request.\n */\nfunction get_labels_input(event_name: FCEvent['name']): string[] {\n  const labels = core.getInput(`${event_name}-labels`) || core.getInput('labels')\n  return labels ? labels.split(',').map(label => label.trim()) : []\n}\n\n/**\n * Retrieves the relevant `-msg` input.\n *\n * Also checks if the message is a symlink to another `-msg`\n * input, and if so, uses the value of the symlinked input instead.\n *\n * For example:\n * ```yaml\n * pr-opened-msg: issue-opened-msg\n * # `getMsgInput()` will return the value of `issue-opened-msg` input\n * ```\n *\n * @param event A `first-contribution` event.\n * @returns Text that can be used as comment.\n */\nfunction get_msg_input(event: FCEvent): string {\n  const message_inputs = [\n    'issue-opened-msg',\n    'issue-completed-msg',\n    'issue-not-planned-msg',\n    'pr-opened-msg',\n    'pr-merged-msg',\n    'pr-closed-msg'\n  ]\n  let msg = core.getInput(`${event.name}-${event.state}-msg`).trim()\n  if (message_inputs.includes(msg)) {\n    msg = core.getInput(msg).trim()\n  }\n  return msg\n}\n\n/**\n * Retrieves the relevant `-reactions` input or a fallback.\n * @param event_name A `first-contribution` event name.\n * @returns An array of reaction emojis to add to the issue or pull request body.\n */\nfunction get_reactions_input(event_name: FCEvent['name']): string[] {\n  const reactions = core.getInput(`${event_name}-reactions`) || core.getInput('reactions')\n  return reactions ? reactions.split(',').map(reaction => reaction.trim()) : []\n}\n","import type { getOctokit } from '@actions/github'\n\n/**\n * Adds labels to the specified issue or pull request.\n * @param octokit A GitHub Octokit client.\n * @param payload_action Action that triggered the event.\n * @param opts {@link AddLabelsOpts}\n */\nexport async function add_labels(\n  octokit: ReturnType<typeof getOctokit>,\n  payload_action: 'opened' | 'closed',\n  opts: AddLabelsOpts\n): Promise<boolean> {\n  // Only add labels for new issues/PRs and when the list of input labels is NOT empty.\n  if (payload_action === 'opened' && opts.labels.length > 0) {\n    // can fail when the specified label is not already created in the repository.\n    await octokit.rest.issues.addLabels({ ...opts })\n    return true\n  }\n  return false\n}\n\ninterface AddLabelsOpts {\n  /** List of labels to add to the issue or pull request. */\n  labels: string[]\n  /** The ID of the issue or pull request to add labels to. */\n  issue_number: number\n  /** Username of the repository's owner. */\n  owner: string\n  /** Name of the repository. */\n  repo: string\n}\n","import * as core from '@actions/core'\nimport type { getOctokit } from '@actions/github'\n\ninterface AddReactionsOpts {\n  /** The owner of the repository. */\n  owner: string\n  /** The name of the repository. */\n  repo: string\n  /** The number of the issue or pull request. */\n  issue_number: number\n  /** An array of valid reaction strings. */\n  reactions: string[]\n}\n\n/**\n * Adds reactions to the main body of an issue or pull request and logs the outcome.\n * @param octokit An authenticated Octokit client.\n * @param payload_action Action that triggered the event.\n * @param opts {@link AddReactionsOpts}\n */\nexport async function add_reactions(\n  octokit: ReturnType<typeof getOctokit>,\n  payload_action: 'opened' | 'closed',\n  opts: AddReactionsOpts\n): Promise<void> {\n  if (payload_action !== 'opened' || opts.reactions.length === 0) {\n    core.info('No reaction was added')\n    return\n  }\n\n  const successful_reactions: string[] = []\n  const failed_reactions: string[] = []\n\n  core.debug(`Attempting to add reactions: ${opts.reactions.join(', ')}`)\n\n  for (const reaction of opts.reactions) {\n    try {\n      await octokit.rest.reactions.createForIssue({\n        owner: opts.owner,\n        repo: opts.repo,\n        issue_number: opts.issue_number,\n        // @ts-expect-error - The type is validated by the API call itself.\n        content: reaction\n      })\n      successful_reactions.push(reaction)\n    } catch {\n      failed_reactions.push(reaction)\n    }\n  }\n\n  if (successful_reactions.length > 0) {\n    core.info(`Reactions added: ${successful_reactions.join(', ')}`)\n  }\n\n  if (failed_reactions.length > 0) {\n    core.warning(`Failed to add reaction(s): ${failed_reactions.join(', ')}`)\n  }\n}\n","import type { getOctokit } from '@actions/github'\n\n/**\n * Creates a comment in the specified issue or pull request.\n * @param octokit A GitHub Octokit client.\n * @param opts {@link CreateCommentOpts}\n * @returns A link to the created comment on GitHub.\n */\nexport async function create_comment(octokit: ReturnType<typeof getOctokit>, opts: CreateCommentOpts): Promise<string> {\n  // Only add comment when body is NOT empty.\n  if (!opts.body) return ''\n\n  // Replace {fc-author} with the issue or pull request author\n  const { author_username, body, ...rest } = opts\n  const transformed_body = body.replaceAll('{fc-author}', author_username)\n\n  // Create a comment on GitHub and return its html_url\n  const comment = await octokit.rest.issues.createComment({ ...rest, body: transformed_body })\n  return comment.data.html_url\n}\n\ninterface CreateCommentOpts {\n  /** The body of the comment to be made. */\n  body: string\n  /** The ID of the issue or pull request to comment on. */\n  issue_number: number\n  /** Username of the repository's owner. */\n  owner: string\n  /** Name of the repository. */\n  repo: string\n  /** Username of the issue or pull request author. */\n  author_username: string\n}\n","import type { context } from '@actions/github'\n\ntype WebhookPayload = (typeof context)['payload']\n\n/**\n * Creates and returns a new `first-contribution` event.\n * @param payload Webhook payload of the triggered event.\n */\nexport function get_fc_event(payload_action: 'opened' | 'closed', payload: WebhookPayload): FCEvent {\n  let action_type: FCEvent['state'] = 'opened'\n\n  if (payload_action === 'closed') {\n    if (payload.pull_request) {\n      // This is a pull request.\n      action_type = payload.pull_request.merged ? 'merged' : 'closed'\n    } else {\n      // This is an issue.\n      action_type = payload.issue?.state_reason === 'completed' ? 'completed' : 'not-planned'\n    }\n  }\n\n  return {\n    state: action_type,\n    name: payload.pull_request ? 'pr' : 'issue'\n  }\n}\n\n/** `first-contribution` custom event. */\nexport interface FCEvent {\n  /** Where the event occurred. */\n  name: 'issue' | 'pr'\n  /** The current state of the event. */\n  state: 'opened' | 'completed' | 'not-planned' | 'merged' | 'closed'\n}\n","import * as core from '@actions/core'\nimport type { getOctokit } from '@actions/github'\n\n/**\n * Checks if an issue or pull request author is a first-time\n * contributor based on the specified contribution mode.\n *\n * @param octokit A GitHub Octokit client.\n * @param opts {@link IsFirstTimeContributorOpts}\n * @returns `true` if the author meets the \"first-time contributor\" criteria for the given event, otherwise `false`.\n */\nexport async function is_first_time_contributor(\n  octokit: ReturnType<typeof getOctokit>,\n  opts: IsFirstTimeContributorOpts\n): Promise<boolean> {\n  const { is_pull_request, creator, owner, repo } = opts\n\n  core.debug('Retrieving commit history')\n\n  // Check for any prior commits by the user\n  const { data: commits } = await octokit.rest.repos.listCommits({\n    owner,\n    repo,\n    author: creator,\n    per_page: 1\n  })\n  core.info(`Author's commit_count: ${commits.length.toString()}`)\n  if (commits.length > 0) {\n    return false\n  }\n\n  core.debug('No prior commits. Retrieving issues and PRs')\n\n  // Fetch all issues and PRs by the author\n  const { data: contributions } = await octokit.rest.issues.listForRepo({\n    creator,\n    owner,\n    repo,\n    state: 'all'\n  })\n\n  const contribution_mode = core.getInput('contribution-mode')\n\n  // Mode 1: Track first contribution ONCE across both issues and PRs.\n  // If the user has exactly one contribution (the one that triggered this workflow),\n  // they are a first-time contributor\n  if (contribution_mode === 'once') {\n    core.info(\"This is the author's first ever contribution to this repo\")\n    return contributions.length === 1\n  }\n\n  // Mode 2: Track first issues and first PRs INDEPENDENTLY.\n  // This is the default behavior. A user can be a first-timer\n  // for an issue and also a first-timer for a pull request\n  if (is_pull_request) {\n    const pr_count = contributions.filter(item => item.pull_request).length\n    core.info(`Author's pr_count: ${pr_count.toString()}`)\n    return pr_count === 1\n  } else {\n    const issue_count = contributions.filter(item => !item.pull_request).length\n    core.info(`Author's issue_count: ${issue_count.toString()}`)\n    return issue_count === 1\n  }\n}\n\ninterface IsFirstTimeContributorOpts {\n  /** Username of the user that created the issue or pull request. */\n  creator: string\n  /** Whether the contribution that triggered the workflow is a pull request. */\n  is_pull_request: boolean\n  /** Username of the repository's owner. */\n  owner: string\n  /** Name of the repository. */\n  repo: string\n}\n","/**\n * Checks whether the triggered event is supported by first-contribution GitHub Action.\n * @param event_name Name of the triggered event.\n * @param [action] Action that caused the event to trigger.\n * @returns\n */\nexport function is_supported_event(event_name: string, action?: string): action is 'opened' | 'closed' {\n  const event_code = `${event_name}.${String(action)}`\n  const supported_event_codes = [\n    'issues.opened',\n    'issues.closed',\n    'pull_request.opened',\n    'pull_request.closed',\n    'pull_request_target.opened',\n    'pull_request_target.closed'\n  ]\n  return supported_event_codes.includes(event_code)\n}\n","import * as core from '@actions/core'\nimport type { getOctokit } from '@actions/github'\nimport type { Issue, PullRequest } from '@octokit/webhooks-types'\n\n/**\n * Checks if the specific issue or pull request that triggered the workflow\n * was the author's very first contribution of that type.\n *\n * @note This works even when the author has multiple issues/PRs.\n * We're only targeting the very first one.\n *\n * @param octokit A GitHub Octokit client.\n * @param opts {@link WasTheFirstContributionOpts}\n * @returns `true` if the event's payload was the user's first contribution.\n */\nexport async function was_the_first_contribution(\n  octokit: ReturnType<typeof getOctokit>,\n  opts: WasTheFirstContributionOpts\n): Promise<boolean> {\n  const { is_pull_request, issue_or_pull_request, ...listForRepo_opts } = opts\n\n  core.debug('Retrieving issues and PRs')\n\n  const { data: contributions } = await octokit.rest.issues.listForRepo({\n    ...listForRepo_opts,\n    state: 'all',\n    sort: 'created',\n    direction: 'asc'\n  })\n\n  core.debug('Filtering for relevant contributions')\n\n  // Filter for either issues or PRs\n  const relevant_contributions = contributions.filter(item =>\n    is_pull_request ? !!item.pull_request : !item.pull_request\n  )\n\n  core.info(`Author's relevant_contributions_count: ${relevant_contributions.length.toString()}`)\n\n  // Re-sort the filtered list just to be sure\n  relevant_contributions.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime())\n\n  // Check if the number of the issue/PR from the event payload\n  // matches the number of the very first item in the sorted list\n  const first_ever_contribution = relevant_contributions.at(0)\n\n  // Should not happen, but as a safeguard\n  if (!first_ever_contribution) {\n    core.info('Interesting...')\n    core.info(`All contributions by @${listForRepo_opts.creator}:\\n${JSON.stringify(contributions)}\\n`)\n    return false\n  }\n\n  core.info(`Author's first_ever_contribution issue/PR number: ${first_ever_contribution.number.toString()}`)\n  return first_ever_contribution.number === issue_or_pull_request.number\n}\n\ninterface WasTheFirstContributionOpts {\n  creator: string\n  is_pull_request: boolean\n  issue_or_pull_request: Issue | PullRequest\n  owner: string\n  repo: string\n}\n","import * as core from '@actions/core'\nimport * as github from '@actions/github'\nimport type { Issue, PullRequest } from '@octokit/webhooks-types'\nimport {\n  add_labels,\n  add_reactions,\n  create_comment,\n  get_action_inputs,\n  get_fc_event,\n  is_first_time_contributor,\n  is_supported_event,\n  was_the_first_contribution\n} from './utils/index.ts'\n\ntype ErrorOccurred = boolean\n\n/**\n * The main function for the action.\n * @returns {Promise<void>} Resolves when the action is complete.\n */\nexport async function run(): Promise<ErrorOccurred> {\n  try {\n    core.debug('Retrieving webhook payload')\n    const payload = github.context.payload\n    const payload_action = payload.action\n    core.debug('Retrieved webhook payload')\n\n    // check if event is supported\n    core.debug('Checking if triggered event is supported')\n    const supported_event = is_supported_event(github.context.eventName, payload_action)\n    if (!supported_event) {\n      core.info(`\\`${github.context.eventName}.${JSON.stringify(payload_action)}\\` event is NOT supported. Exiting..`)\n      return false\n    }\n    core.debug(`Supported event: \\`${github.context.eventName}.${payload_action}\\``)\n\n    // create octokit client\n    core.debug('Retrieving `token` input')\n    const token = core.getInput('token', { required: true })\n    core.debug('`token` input retrieved')\n    core.debug('Creating octokit client')\n    const octokit = github.getOctokit(token)\n    core.debug('Octokit client created')\n\n    // helper variables\n    const is_pull_request = !!payload.pull_request\n    const issue_or_pull_request = (payload.issue ?? payload.pull_request) as Issue | PullRequest\n    const first_timer_username = issue_or_pull_request.user.login\n    const fc_event = get_fc_event(payload_action, payload)\n    const interaction = fc_event.name === 'issue' ? 'issue' : 'pull request'\n\n    // check if author is first-timer\n    core.debug(`Checking if ${interaction} is a first-time contribution from its author`)\n    let is_relevant_first_timer = false\n    if (payload_action === 'opened') {\n      core.debug('Event is \"opened\". Checking for first-time contributor.')\n      is_relevant_first_timer = await is_first_time_contributor(octokit, {\n        ...github.context.repo,\n        creator: first_timer_username,\n        is_pull_request\n      })\n    } else {\n      core.debug('Event is \"closed\". Checking if this was their first contribution.')\n      is_relevant_first_timer = await was_the_first_contribution(octokit, {\n        ...github.context.repo,\n        creator: first_timer_username,\n        is_pull_request,\n        issue_or_pull_request\n      })\n    }\n\n    if (!is_relevant_first_timer) {\n      core.info(`\\`${first_timer_username}\\` does not meet the criteria for being a first timer. Exiting..`)\n      return false\n    }\n\n    core.debug('Author meets the criteria for this event.')\n\n    // retrieve inputs\n    core.debug('Retrieving relevant message and labels inputs')\n    const action_inputs = get_action_inputs(fc_event)\n    core.debug('Message and labels inputs retrieved')\n\n    // add reactions\n    core.debug(`Attempting to react with: ${action_inputs.reactions.toString()}`)\n    await add_reactions(octokit, payload_action, {\n      ...github.context.repo,\n      issue_number: issue_or_pull_request.number,\n      reactions: action_inputs.reactions\n    })\n\n    // create comment\n    core.debug('Attempting to create comment on GitHub')\n    const comment_url = await create_comment(octokit, {\n      ...github.context.repo,\n      body: action_inputs.msg,\n      issue_number: issue_or_pull_request.number,\n      author_username: first_timer_username\n    })\n    core.info(comment_url ? `Comment created: ${comment_url}` : 'No comment was added')\n\n    // add labels\n    core.debug(`Attempting to add labels to ${interaction}`)\n    const did_add_labels = await add_labels(octokit, payload_action, {\n      ...github.context.repo,\n      labels: action_inputs.labels,\n      issue_number: issue_or_pull_request.number\n    })\n    core.info(did_add_labels ? `Labels added: ${action_inputs.labels.toString()}` : 'No label was added')\n\n    core.setOutput('comment-url', comment_url)\n    core.setOutput('number', issue_or_pull_request.number)\n    core.setOutput('type', fc_event.name)\n    core.setOutput('username', first_timer_username)\n\n    return false\n  } catch (error) {\n    const fail_on_error = core.getBooleanInput('fail-on-error')\n    const message = error instanceof Error ? error.message : `Unknown error: ${JSON.stringify(error)}`\n\n    if (fail_on_error) {\n      core.setFailed(message)\n    } else {\n      core.error(message)\n    }\n    return true\n  }\n}\n","/**\n * The entrypoint for the action.\n */\nimport { run } from './main.ts'\n\nvoid run()\n"],"mappings":"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"}