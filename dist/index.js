import*as e from"@actions/core";import*as t from"@actions/github";function n(e){return{labels:r(e.name),msg:i(e),reactions:a(e.name)}}function r(t){let n=e.getInput(`${t}-labels`)||e.getInput(`labels`);return n?n.split(`,`).map(e=>e.trim()):[]}function i(t){let n=[`issue-opened-msg`,`issue-completed-msg`,`issue-not-planned-msg`,`pr-opened-msg`,`pr-merged-msg`,`pr-closed-msg`],r=e.getInput(`${t.name}-${t.state}-msg`).trim();return n.includes(r)&&(r=e.getInput(r).trim()),r}function a(t){let n=e.getInput(`${t}-reactions`)||e.getInput(`reactions`);return n?n.split(`,`).map(e=>e.trim()):[]}async function o(e,t,n){return t===`opened`&&n.labels.length>0?(await e.rest.issues.addLabels({...n}),!0):!1}async function s(t,n,r){if(n!==`opened`||r.reactions.length===0){e.info(`No reaction was added`);return}let i=[],a=[];e.debug(`Attempting to add reactions: ${r.reactions.join(`, `)}`);for(let e of r.reactions)try{await t.rest.reactions.createForIssue({owner:r.owner,repo:r.repo,issue_number:r.issue_number,content:e}),i.push(e)}catch{a.push(e)}i.length>0&&e.info(`Reactions added: ${i.join(`, `)}`),a.length>0&&e.warning(`Failed to add reaction(s): ${a.join(`, `)}`)}async function c(e,t){if(!t.body)return``;let{author_username:n,body:r,...i}=t,a=r.replaceAll(`{fc-author}`,n);return(await e.rest.issues.createComment({...i,body:a})).data.html_url}function l(e,t){let n=`opened`;return e===`closed`&&(n=t.pull_request?t.pull_request.merged?`merged`:`closed`:t.issue?.state_reason===`completed`?`completed`:`not-planned`),{state:n,name:t.pull_request?`pr`:`issue`}}async function u(t,n){let{is_pull_request:r,creator:i,owner:a,repo:o}=n;e.debug(`Retrieving commit history`);let{data:s}=await t.rest.repos.listCommits({owner:a,repo:o,author:i,per_page:1});if(e.info(`Author's commit_count: ${s.length.toString()}`),s.length>0)return!1;e.debug(`No prior commits. Retrieving issues and PRs`);let{data:c}=await t.rest.issues.listForRepo({creator:i,owner:a,repo:o,state:`all`});if(e.getInput(`contribution-mode`)===`once`)return e.info(`This is the author's first ever contribution to this repo`),c.length===1;if(r){let t=c.filter(e=>e.pull_request).length;return e.info(`Author's pr_count: ${t.toString()}`),t===1}else{let t=c.filter(e=>!e.pull_request).length;return e.info(`Author's issue_count: ${t.toString()}`),t===1}}function d(e,t){let n=`${e}.${String(t)}`;return[`issues.opened`,`issues.closed`,`pull_request.opened`,`pull_request.closed`,`pull_request_target.opened`,`pull_request_target.closed`].includes(n)}async function f(t,n){let{is_pull_request:r,issue_or_pull_request:i,...a}=n;e.debug(`Retrieving issues and PRs`);let{data:o}=await t.rest.issues.listForRepo({...a,state:`all`,sort:`created`,direction:`asc`});e.debug(`Filtering for relevant contributions`);let s=o.filter(e=>r?!!e.pull_request:!e.pull_request);e.info(`Author's relevant_contributions_count: ${s.length.toString()}`),s.sort((e,t)=>new Date(e.created_at).getTime()-new Date(t.created_at).getTime());let c=s.at(0);return c?(e.info(`Author's first_ever_contribution issue/PR number: ${c.number.toString()}`),c.number===i.number):(e.info(`Interesting...`),e.info(`All contributions by @${a.creator}:\n${JSON.stringify(o)}\n`),!1)}async function p(){try{e.debug(`Retrieving webhook payload`);let r=t.context.payload,i=r.action;if(e.debug(`Retrieved webhook payload`),e.debug(`Checking if triggered event is supported`),!d(t.context.eventName,i))return e.info(`\`${t.context.eventName}.${JSON.stringify(i)}\` event is NOT supported. Exiting..`),!1;e.debug(`Supported event: \`${t.context.eventName}.${i}\``),e.debug("Retrieving `token` input");let a=e.getInput(`token`,{required:!0});e.debug("`token` input retrieved"),e.debug(`Creating octokit client`);let p=t.getOctokit(a);e.debug(`Octokit client created`);let m=!!r.pull_request,h=r.issue??r.pull_request,g=h.user.login,_=l(i,r),v=_.name===`issue`?`issue`:`pull request`;e.debug(`Checking if ${v} is a first-time contribution from its author`);let y=!1;if(i===`opened`?(e.debug(`Event is "opened". Checking for first-time contributor.`),y=await u(p,{...t.context.repo,creator:g,is_pull_request:m})):(e.debug(`Event is "closed". Checking if this was their first contribution.`),y=await f(p,{...t.context.repo,creator:g,is_pull_request:m,issue_or_pull_request:h})),!y)return e.info(`\`${g}\` does not meet the criteria for being a first timer. Exiting..`),!1;e.debug(`Author meets the criteria for this event.`),e.debug(`Retrieving relevant message and labels inputs`);let b=n(_);e.debug(`Message and labels inputs retrieved`),e.debug(`Attempting to react with: ${b.reactions.toString()}`),await s(p,i,{...t.context.repo,issue_number:h.number,reactions:b.reactions}),e.debug(`Attempting to create comment on GitHub`);let x=await c(p,{...t.context.repo,body:b.msg,issue_number:h.number,author_username:g});e.info(x?`Comment created: ${x}`:`No comment was added`),e.debug(`Attempting to add labels to ${v}`);let S=await o(p,i,{...t.context.repo,labels:b.labels,issue_number:h.number});return e.info(S?`Labels added: ${b.labels.toString()}`:`No label was added`),e.setOutput(`comment-url`,x),e.setOutput(`number`,h.number),e.setOutput(`type`,_.name),e.setOutput(`username`,g),!1}catch(t){let n=e.getBooleanInput(`fail-on-error`),r=t instanceof Error?t.message:`Unknown error: ${JSON.stringify(t)}`;return n?e.setFailed(r):e.error(r),!0}}p();
//# sourceMappingURL=index.js.map